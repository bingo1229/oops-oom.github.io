# 提高物理机的利用率

## 物理机 - physical machine

<img src="http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-31-150839.jpg" alt="img" style="zoom: 33%;" />

依靠异步调用或者协程，提高了单个应用对于cpu的利用率。但是怎么如何提高整台物理机的cpu利用率呢？

最直接的方式是直接在物理机上部署等多个应用，但是安全性怎么保证，尤其是在云上，两个应用可能属于两个不同的客户？

即便是同一客户的两个应用，也需要避免相互影响。另外不同的应用可能依赖的环境也不一样。

## 虚拟机 - vitual machine

因此虚拟机出现了，[虚拟机的概念](https://www.ispsystem.com/news/brief-history-of-virtualization)其实更早的时候就有了。一些虚拟机的技术相关的链接[kvm](https://en.wikipedia.org/wiki/Kernel-based_Virtual_Machine)、[xen](https://en.wikipedia.org/wiki/Xen)、[hypervisor](https://en.wikipedia.org/wiki/Hypervisor)

<img src="http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-31-095510.png" alt="virtualization" style="zoom:50%;" />

图片摘自[hardware-assisted virtualization](https://www.techtarget.com/searchitoperations/definition/hardware-assisted-virtualization)

> 关于虚拟化的一些学习资料
>
> [VMware_paravirtualization](https://www.vmware.com/content/dam/digitalmarketing/vmware/en/pdf/techpaper/VMware_paravirtualization.pdf)

同时也出现了虚拟机的编排系统(IAAS),即所谓的[云操作系统](https://www.zhihu.com/question/357973113)，阿里云飞天系统、[腾讯vStation](https://www.infoq.cn/article/2018/04/tencent-vstation-cvm)、华为云FusionSphere、Microsoft Azure、以及开源的OpenStack。

由于虚拟机要虚拟硬件+运行操作系统，导致其overhead会比较高。那有没有办法解决这个问题呢？

## 容器 - cgroups namespace sandbox

<img src="http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-06-160022.png" alt="image-20230105215322799" style="zoom:50%;" />
图片摘自[阿里云与CNCF联合推出的云原生技术公开课](https://www.bilibili.com/video/BV1r7411r7h7/)

Linux内核通过cgroups提供了限制进程资源使用的功能(resource 隔离)，namespace的存在则让不同进程看到不同的系统视图(view 隔离)。

<img src="http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-31-132932.png" alt="img" style="zoom:80%;" />

以Cloud Foundry 为代表的开源 PaaS 项目开始基于cgroups、namespace在同一台虚拟机上部署多个应用。(参考自[深入剖析 Kubernetes](https://time.geekbang.org/column/article/14254))

> 事实上，像 Cloud Foundry 这样的 PaaS 项目，最核心的组件就是一套应用的打包和分发机制。 Cloud Foundry 为每种主流编程语言都定义了一种打包格式，而“cf push”的作用，基本上等同于用户把应用的可执行文件和启动脚本打进一个压缩包内，上传到云上 Cloud Foundry 的存储中。接着，Cloud Foundry 会通过调度器选择一个可以运行这个应用的虚拟机，然后通知这个机器上的 Agent 把应用压缩包下载下来启动。
>

由于是把应用打包上传、分发、运行，那如果本地环境与云上环境(依赖库是否存在、依赖库的版本是否一致)不一致会不会导致应用执行失败？

所以经常会出现以下甩锅技巧。

> [程序在我这跑得好好的，在你那怎么就不行呢？！](https://my.oschina.net/morflameblog/blog/318768)
>
> 在我电脑上是好的
>
> 一定是你的环境不对

## docker - build once, run anywhere

所以如何解决本地环境与云上环境可能存在的不一致问题呢？

Docker的出现解决了这个问题。Docker并没有引入什么新的思想、技术，底层的技术原理[cgroups + namespace + unionfs]其实很早就存在了，但是它的出现极大优化了程序员的体验：

1. 通过rootfs + UnionFS(overlayfs、AUFS) 解决了本地环境与云上环境不一致的问题，其实就是将环境和应用一起打包到了镜像中；

2. docker提供了非常友好的接口;

   - 开发者可以随意打包、分发、运行容器

   - 屏蔽了cgroups、namespace、UnionFS等概念，使用虚拟机一样使用容器[可登陆、可执行shell]的同时还避免了虚拟机的开销，极大的优化了程序员的开发和调试体验。

3. 因为优化了开发者的体验、导致其在开发者中流行，开发者又反过来帮助docker完善了生态系统;

这里就先不详细说rootfs + UnionFS的概念了,感兴趣可以先看[DOCKER基础技术：AUFS](https://coolshell.cn/articles/17061.html)，后续有空填坑。

> implements a [union mount](https://en.wikipedia.org/wiki/Union_mount) for other file systems. It allows files and directories of separate file systems, known as branches, to be transparently overlaid, forming a single coherent file system.
> Contents of directories which have the same path within the merged branches will be seen together in a single merged directory, within the new, virtual filesystem.
>
> This allows a file system to appear as writable, but without actually allowing writes to change the file system, also known as **[copy-on-write](https://en.wikipedia.org/wiki/Copy-on-write)**
>
> 摘自[UnionFS](https://en.wikipedia.org/wiki/UnionFS)

> At the bottom of the Linux system is the system kernel, and a typical Linux boot requires two File systems bootfs and rootfs.
>
> Bootfs (boot file system) mainly contains bootloader and kernel. bootloader mainly boots the kernel. bootfs are umount after boot is successful and the kernel is loaded into memory.
>
> So bootfs are basically the same for different Linux distributions, and rootfs are different, so different distributions can share bootfs 
>
> rootfs (root file system) 包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。
> <img src="http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-06-160029.png" alt="img" style="zoom:67%;" />
>
> 摘自[difference-between-docker-and-virtual-machine](https://studyk8s.com/2021/03/29/difference-between-docker-and-virtual-machine/)

AUFS的存在

- 优化了镜像存储大小，更易分发和存储; 
- 把容器运行时的变更隔离在writable layer, 提供了不可变基础设施。

>The major difference between a container and an image is the top writable layer. All writes to the container that add new or modify existing data are stored in this writable layer. When the container is deleted, the writable layer is also deleted. The underlying image remains unchanged.
>
>Storage drivers are optimized for space efficiency, but (depending on the storage driver) write speeds are lower than native file system performance, especially for storage drivers that use a copy-on-write filesystem. Write-intensive applications, such as database storage, are impacted by a performance overhead, particularly if pre-existing data exists in the read-only layer.
>
><img src="http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-06-134053.jpg" alt="Containers sharing same image" style="zoom: 67%;" />
>
>摘自[docker storagedriver](https://docs.docker.com/storage/storagedriver/)

### 容器的本质是一个进程(组)

rootfs + UnionFS的存在，外加cgroups + namespace提供的resource和view的隔离，就是完整的docker的底层原理。

由于**容器的本质是一个进程**，导致只有应用本身能在对应操作系统上跑起来，其封装成的镜像，才能在对应操作系统上跑起来。

> Applications that run on docker are limited to applications that are natively supported by the host operating system.
>
> In other words, Docker for Windows can only host Windows applications inside Docker containers, and Docker on Linux supports only Linux apps.

那么[为什么我的容器既可以在linux上运行，又可以在mac上运行](https://collabnix.com/how-docker-for-mac-works-under-the-hood/)？

实际上，这句话其实仅适用于共享内核的容器，后面还有提到安全容器不符合这种说法。

#### 瘦容器 vs 胖容器 - thin container vs fat container

一般情况下，Linux操作系统的1号进程是init/systemd。而容器的1号进程一般是应用进程，这种容器一般称为thin container。

胖容器其实就是把容器当成虚拟机用，是容器发展初期为了快速方便迁移的妥协方案，而创造出来的概念。新增业务强烈不建议使用。

### docker arch

最初的时候docker只有docker-cli和docker daemon，随着社区的发展、伴随着K8S及CNCF的发展壮大，docker daemon被拆分成docker deamon、containerd、container-shim、runc。

<img src="http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-09-143534.png" alt="img" style="zoom:80%;" />

#### docker daemon 

上图中的docker为docker daemon， docker-daemon负责与docker命令行交互，通过gRPC通讯。

docker build命令的最终执行者，依赖BuildKit。

docker run、docker pull等命令则会通过gRPC转发给containerd，由containerd最终执行。

<img src="http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-10-163713.png" alt="arch" style="zoom:100%;" />

图片摘自[buildkit](http://gaocegege.com/Blog/kubernetes/buildkit)

#### containerd - CNCF

containerd 是CRI接口的一个实现、从docker中拆分出来，所谓的[high level container runtime](https://www.ianlewis.org/en/container-runtimes-part-1-introduction-container-r)。而[CRI](https://github.com/kubernetes/cri-api/blob/master/pkg/apis/services.go)说白了其实就是gRPC接口协议的定义，主要定义了容器的整个生命周期的管理接口以及镜像管理相关的操作。

其实通过crictl命令所支持的功能就是CRI所定义的功能、而功能的最终实现则是由CRI的实现来定义。

- crictl 支持cri的命令行工具

- ctr containerd的命令行工具、比crictl支持更多的功能，比如push

- nerdctl 对标docker命令行，其中build命令依赖buildkit，其他命令依赖containerd

从命令行支持的功能就可以看出，其实containerd是支持了CRI以外的更多功能，比如镜像push、tag。

<img src="http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-10-164206.jpg" alt="img" style="zoom:80%;" />

#### container-shim

container-shim 避免containerd异常、重启等导致对应容器挂掉。

#### runc

runc OCI实现、从docker中拆分出来，所谓的low level container runtime。由于OCI的存在，这里的runc可以被替换为crun、runv、runsc等OCI实现。

runc的主要任务是负责整个容器的生命周期，包括创建、删除、列表。

<img src="http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-10-143748.png" alt="img" style="zoom:50%;" />



<img src="http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-10-162653.png" alt="Docker" style="zoom:100%;" />

[oci-containers](https://iximiuz.com/en/posts/oci-containers/)


## 容器 vs 虚拟机 - containers vs VM

<img src="http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-09-032812.png" alt="image-20230109112804330" style="zoom:67%;" />

图片摘自[K8S Overview](https://kubernetes.io/docs/concepts/overview/)

### 实现原理 - implementation

在使用者看来，虚拟机和容器都是一个独立的操作系统，而实质上容器仅仅是操作系统上的一个进程，同一系统上的容器是共享同一内核的,只是给用户的感觉像是一个操作系统[OS virtualization,广义的虚拟化,实际上没有虚拟化的overhead]。虚拟机是完全隔离的操作系统,是真实的在宿主机虚拟化的硬件硬件上运行的完全独立的操作系统。[Hardware-level virtualization]。

### 性能 - performance

- 虚拟机由于需要运行完整的操作系统，导致virtualization overhead，而容器由于本质就是宿主机上的进程，所以没有virtualization overhead。

- 虚拟机的启动时间：拉取镜像、 操作系统启动、进程启动； 容器的启动时间：拉取镜像、进程启动。 容器的启动时间没了操作系统的启动，而且如下镜像的大小也会小很多，导致容器的启动时间[秒级]会比虚拟机[分钟级]快了好多。

### 镜像 - image

- 虚拟机的镜像会包含整个操作系统，导致 镜像体积会很大，从而影响分发和存储。
- docker镜像由于overlayfs、AUFS等存在，让docker镜像变的更易分发并且占用更小的存储。

### 安全 - isolation security

由于容器会共享操作系统内核，导致类似[容器逃逸](https://goteleport.com/blog/stop-container-escape-privilege-escalation/)等安全问题。当然[虚拟机逃逸](http://www.gjbmj.gov.cn/n1/2021/0513/c411145-32102364.html)也可能会发生，但是由于容器与宿主系统共享内核，因此容器与宿主机有着更大的接触面，隔离层次更少，更容易从容器内实施逃逸攻击。更多细节可参考[云原生2.0时代，企业都应该了解的容器安全](https://bbs.huaweicloud.com/blogs/245352)、[什么是容器安全？包含哪些机制](https://baijiahao.baidu.com/s?id=1738224075663211718&wfr=spider&for=pc)、[How to Stop Container Escape and Prevent Privilege Escalation](https://goteleport.com/blog/stop-container-escape-privilege-escalation/)、[虚拟机中的病毒是如何逃逸的?](https://www.zhihu.com/question/328249702)

- Seccomp：系统调用过滤。
- SElinux：限制容器进程、文件和用户的权限。
- Capability：限制容器进程Capability。
- dockerdrootless模式：禁止用户以root身份运行Docker守护进程和容器。

虽然以上措施可以在一定程度上强化runC容器的安全性，降低恶意容器应用攻击Host Kernel的几率，但是仍然无法解决容器逃逸利用Host Kernel漏洞的安全问题。

基于以上，容器和虚拟机各有优缺点，短期内不存在所谓的替代关系。**所以目前的主流场景是购买虚拟机、部署k8s、然后部署容器。**

讲道理，虚拟机 + 容器方式已经能满足绝大多数需求了，但是云服务商如果想直接卖容器服务(让用户直接在云上运行镜像)应该怎么办呢？类似[AWS lambda](https://aws.amazon.com/lambda/)、[阿里云的ECI](https://www.aliyun.com/product/eci)、[腾讯云的函数服务](https://console.cloud.tencent.com/scf/list-create?rid=1&ns=default&createType=container)、[阿里云的函数计算 FC](https://www.aliyun.com/product/fc?spm=5176.19720258.J_3207526240.41.a4b976f454tcQd)、 华为云的CCI】<img src="http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-08-083825.png" alt="租户" style="zoom:67%;" />
<img src="http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-08-083848.png" alt="节点" style="zoom:67%;" />
部分摘自[为什么选择安全沙箱？](https://www.alibabacloud.com/help/zh/container-service-for-kubernetes/latest/benefits-of-sandboxed-container)

## 沙盒 - sandbox(vs container)

**多租户服务、执行不可信代码[容器逃逸]、混合部署[节点性能波动]**等场景下，我们希望同时拥有虚拟机一样的安全性、又拥有容器的性能呢？

现在主流的有两种方案：

1. microVM/LightweightVM

   - [Kata Containers](https://katacontainers.io/) - OCI
   - AWS Firecracker

   相对docker依然有virtualization overhead，startup time slower，只是比虚拟机提升了不少。

2. 以普通非特权进程方式运行的内核(Partial Kernel in userspace)
   - [gVisor](https://github.com/google/gvisor) - OCI

![image-20230107191109094](http://devops-1255386119.cos.ap-beijing.myqcloud.com/2023-01-07-111115.png)

[kata-containers-vs-gvisor](https://stackoverflow.com/questions/50143367/kata-containers-vs-gvisor)

沙盒的存在，不仅仅可以满足多租户、多租户服务、执行不可信代码、混合部署的需求，还让云上有了一台宿主机上可以同时部署虚拟机和沙盒的能力，从而有效利用云上的碎片资源。

## Open Container Initiative - OCI

随着docker的广泛流行，docker 逐渐成为了容器的事实标准。然而社区逐渐意识到，

1. docker公司的话语权过大(毕竟大家都在用，不能docker随性而为)，
2. 有些公司希望有自己的container runtime实现，没有标准导致互不兼容、不利于生态和创新

于是2015年6月在社区的压力下，Docker公司将从Docker源码中拆分出来的container runtime [runc](https://github.com/opencontainers/runc)([libcontainer](https://github.com/docker-archive/libcontainer))项目捐献出来，然后和其他一些巨头以runc为基础,开始制定一套容器和镜像的规范。

- 容器运行时标准 - runtime-spec
- 容器镜像标准 - image-spec
- 容器分发标准 - distribution-spec [后续新增]

因此runc就是OCI标准的第一个实现版本，后续也逐渐发展出一些新的实现比如crun、runv(kata container by alibaba)、runsz(gVisor by google)

- runc/crun 共享内核、通常意义上的容器、狭义的容器定义

- runv ->  kata containers microVM、也可以被称为容器

- runsz -> gVisor
